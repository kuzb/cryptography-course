import random
import warnings


def egcd(a, b):
    x, y, u, v = 0, 1, 1, 0
    while a != 0:
        q, r = b//a, b % a
        m, n = x-u*q, y-v*q
        b, a, x, y, u, v = a, r, u, v, m, n
    gcd = b
    return gcd, x, y


def modinv(a, m):
    gcd, x, y = egcd(a, m)
    if gcd != 1:
        return None  # modular inverse does not exist
    else:
        return x % m


# This is an example to show how the conversion between integers and bytes is done
message = b'Be yourself; everyone else is already taken.'
m = int.from_bytes(message, byteorder='big')
print("Message: ", m.to_bytes((m.bit_length()+7)//8, byteorder='big'))

n = 7473729494541494368852084160833887966786966146604539788038425546370721005202575292878010603718779143680279072437859979437027212668979951812104144364476251149631445677106574998958718100538368157559892086233484623658307080278702230379266872415713089871004732096589645883883977415506508347976001334807533323619602524830567712971581132341673584628698079736760920789626175805249978676215337039548212810503820392130214528748452439765014841123109184880811527461970066588991000432403773750048368279867220678747020767042484253902752403310560243017584585301433673020033953058809415002025715734068685302158511640316340598416777
e = 65537

# Alice encrypts her RSA private keys p and q
cp = 6237092736280340368143892975246879700280574956823483459089826300838549326698371192841125256658301422335506071280990036134969958430140091821413942110999828019223701914534660496145184049436793233117527141710469587852896572612908205944874924666105935993339272072516489985048899803563277390008625395078803685108980714466378814566336644612044895653938680103088252710048504048952616260337657469904426834625756755178823712343160146527660412642787198955050511984140986234095815703702908475146055296882216504049042640234735532803592978062118777287332266867117935272468491447326467928608953581142170727780193982988625594898212
cq = 6792216459178320663134922113672614244133286795167205940387994163295121940464502516578964764558190390582955957319087527927606354995278787002827810252216604393602551619997059706389437721444109986118687258571558770491123542808098899449070164438070259725300867432155155552476715445078689763334188428800272552596349007005222835623783668243124391007979542657577232082178629086100963707200714469436928816142276093722080937180495045103388174875710073753498922326189147660992582560179759354313355942469090808651587693854760749192023182331797094543656070987815654088544115591473666250129130603910045357579318640054232668524224
cm = 2105477800955456357154507258188617457189736593253101663074145074953981395245071021806753010279680874168054072882966675195121143457746629686736359549415401549852363809597210114934407644579644329802951418430994896968996554627286997788295104796260715656641752826531876202868222659539111193689690587665763970475954283298561326716629497355710903035324921787171114135903504002506114489283933796611287777504398400559494459519397397254887260526830796723748881723043560212833332272718498671835837847760126707870313591817583090393736883523163338481442463241882375466824267640258884419635167163135753490195544303858749215914789

# Your mission is to show that you can factor n, find p and q, and decrypt cm
print("A)\n")
print("It is not secure. The usage of Cp and Cq, allows adversary to find the the factors of n i.e. n = p x q. Because gcd(Cp,n) = p and gcd(Cq,n) = q.\n")

print("B) \n")
print("Finding Factors of n using Cp and Cq with gcd n")
(p, x, y) = egcd(cp, n)
print("p:", p)
(q, x, y) = egcd(cq, n)
print("q:", q)

print("\nLet's confirm them just in case")
if int(n//q) == p and int(n//p) == q:
    print("P and Q are confirmed")

phi = (p-1)*(q-1)
print("\nphi i.e. (p-1)(q-1) =", phi)

d = modinv(e, phi)
print("\nDecryption key is", d)

m = pow(cm, d, p*q)
print("\nMessage: ", m.to_bytes((m.bit_length()+7)//8, byteorder='big'))
